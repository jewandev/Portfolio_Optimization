hw_d.fore <- forecast(hw, h = length(test))
accuracy(hw_d.fore, test)
# 5. 실제값, 적합된 값, 예측값을 차트로 표현하기.
autoplot(train) +
autolayer(fitted(ets.fore), series = "fitted") +
autolayer(ets.fore, series = "predicted") +
ggtitle("ETS(M, Md, M)") + ylab("")
# 6. 잔차와 예측오차 (5번에서 선정된 모형을 바탕으로) 평가하기
par(family='AppleGothic')
par(mfrow = c(1, 2))
plot(as.vector(ets.fore$residuals), main = '잔차')
plot(as.vector(train - ets.fore$model$fitted), main = '예측오차')
library(forecast)
library(fpp2)
par(mfrow = c(1, 1))
plot(usmelec)
# 1. 각 단순지수평활법, 홀트, 홀트-윈터스 모형 구축하기.
# ses
ses <- ses(usmelec, initial="simple")
summary(ses)
# holt
holt <- holt(usmelec, damped=TRUE)
summary(holt)
# hw
hw <- hw(usmelec, seasonal = "multiplicative")
summary(hw)
plot(hw)
lines(fitted(hw), col = "red")
plot(holt)
lines(fitted(holt), col = "red")
plot(hw)
lines(fitted(hw), col = "red")
par(mfrow = c(1, 2))
plot(as.vector(ets.fore$residuals), main = '잔차')
plot(as.vector(test - ets.fore$model$fitted), main = '예측오차')
library(forecast)
library(fpp2)
par(mfrow = c(1, 1))
plot(usmelec)
# 1. 각 단순지수평활법, 홀트, 홀트-윈터스 모형 구축하기.
# ses
ses <- ses(usmelec, initial="simple")
summary(ses)
# holt
holt <- holt(usmelec, damped=TRUE)
summary(holt)
# hw
hw <- hw(usmelec, seasonal = "multiplicative")
summary(hw)
# 2. 모형 적합 후, 원데이터와 적합된(fitted) 데이터를 차트로 표현하기.
par(mfrow = c(1, 1))
plot(ses)
lines(fitted(ses), col = "red")
plot(holt)
lines(fitted(holt), col = "red")
plot(hw)
lines(fitted(hw), col = "red")
# 최적 alpha 찾기
i <- 0.01
alpha <- c()
rmse <- c()
while(i<1) {
ses <- ses(usmelec, initial = "simple", alpha = i)
rmse <- c(rmse, sqrt(mean((usmelec - ses$fitted)^2)))
alpha <- c(alpha, i)
i <- i+0.01
}
# 최적 alpha
alpha[which(rmse == min(rmse))]
# 그래프
plot(x=alpha, y=rmse, type='l', xlab="alpha", ylab="RMSE")
# 4. 학습데이터와(1973.1 ~ 2011.12) 테스트데이터(2012년 1월 -2013년 6월) 구분하고, 예측성과를 각각 평가하시오.
train <- window(usmelec, start = 1973, end = c(2011,12))
test <- window(usmelec, start = 2012)
ses <- ses(train, initial = "simple", alpha = 0.99, h=length(test))
ses.fore <- forecast(ses)
accuracy(ses.fore, test)
holt_d <- holt(train, h = length(test), damped = TRUE)
holt_d.fore <- forecast(holt)
accuracy(holt_d.fore, test)
hw <- hw(train, seasonal = "multiplicative", damped = TRUE)
hw_d.fore <- forecast(hw, h = length(test))
accuracy(hw_d.fore, test)
ets_mmdm <- ets(train, model = "MMM", damped = TRUE)
ets_mmdm.fore <- forecast(ets, h = length(test))
accuracy(ets_mmdm.fore, test)
# 5. 실제값, 적합된 값, 예측값을 차트로 표현하기.
autoplot(train) +
autolayer(fitted(ets.fore), series = "fitted") +
autolayer(ets.fore, series = "predicted") +
ggtitle("ETS(M, Md, M)") + ylab("")
# 6. 잔차와 예측오차 (5번에서 선정된 모형을 바탕으로) 평가하기
par(family='AppleGothic')
par(mfrow = c(1, 2))
plot(as.vector(ets.fore$residuals), main = '잔차')
plot(as.vector(test - ets.fore$model$fitted), main = '예측오차')
par(mfrow = c(1, 2))
plot(as.vector(ets_mmdm.fore$residuals), main = '잔차')
plot(as.vector(test - ets_mmdm.fore$model$fitted), main = '예측오차')
ets_mmdm <- ets(train, model = "MMM", damped = TRUE)
ets_mmdm.fore <- forecast(ets, h = length(test))
# 4. 학습데이터와(1973.1 ~ 2011.12) 테스트데이터(2012년 1월 -2013년 6월) 구분하고, 예측성과를 각각 평가하시오.
train <- window(usmelec, start = 1973, end = c(2011,12))
test <- window(usmelec, start = 2012)
ses <- ses(train, initial = "simple", alpha = 0.99, h=length(test))
ses.fore <- forecast(ses)
accuracy(ses.fore, test)
holt_d <- holt(train, h = length(test), damped = TRUE)
holt_d.fore <- forecast(holt)
accuracy(holt_d.fore, test)
hw <- hw(train, seasonal = "multiplicative", damped = TRUE)
accuracy(holt_d.fore, test)
length(test)
ses <- ses(train, initial = "simple", alpha = 0.99, h=length(test))
ses.fore <- forecast(ses)
accuracy(ses.fore, test)
holt_d <- holt(train, h = length(test), damped = TRUE)
holt_d.fore <- forecast(holt)
accuracy(holt_d.fore, test)
holt_d.fore
accuracy(holt_d.fore, test)
### 4/29 ----
beer2 <- window(ausbeer,start=1992, end=c(2007,4))
library(fpp2)
### 4/29 ----
beer2 <- window(ausbeer,start=1992, end=c(2007,4))
autoplot(beer2) +
autolayer(meanf(beer2, h=11), series="Mean", PI=FALSE) +
autolayer(naive(beer2, h=11), series="Naive", PI=FALSE) +
autolayer(snaive(beer2, h=11), series="Seasonal naive", PI=FALSE) +
ggtitle("Forecasts for quarterly beer production") +
xlab("Year") + ylab("Megalitres") +
guides(colour=guide_legend(title="Forecast"))
autoplot(goog200) +
autolayer(meanf(goog200, h=40), series="Mean", PI=FALSE) +
autolayer(rwf(goog200, h=40), series="Naive", PI=FALSE) +
autolayer(rwf(goog200, drift=TRUE, h=40), series="Drift", PI=FALSE) +
ggtitle("Google stock (daily ending 6 Dec 2013)") +
xlab("Day") + ylab("Closing Price (US$)") +
guides(colour=guide_legend(title="Forecast"))
ausbeer
# meanf(), rwf(), snaive() 로 예측하기
# 데이터 : ausbeer
train <- window(ausbeer,start=1992, end=c(2007,4))
test <- window(ausbeer, start = c(2008,1))
meanf <- meanf(train, h=11)
rwf <- rwf(train, h=11)
snaive <- snaive(train, h=11)
snaive
accuracy(meanf, test)
rwf <- rwf(train, h=11)
accuracy(rwf, test)
snaive <- snaive(train, h=11)
accuracy(snaive, test)
meanf <- meanf(train, h=11)
accuracy(meanf, test)
rwf <- rwf(train, h=11)
accuracy(rwf, test)
snaive <- snaive(train, h=11)
accuracy(snaive, test)
meanf <- meanf(train, h=11)
accuracy(meanf, test)
rwf <- rwf(train, drift = T, h=11)
accuracy(rwf, test)
rwf <- rwf(train, h=11)
accuracy(rwf, test)
meanf <- meanf(train, h=10)
accuracy(meanf, test)
rwf <- rwf(train, h=10)
accuracy(rwf, test)
snaive <- snaive(train, h=10)
accuracy(snaive, test)
autoplot(beer2) +
autolayer(meanf, series="Mean", PI=FALSE) +
autolayer(rwf, series="Naive", PI=FALSE) +
autolayer(snaive, series="Seasonal naive", PI=FALSE) +
ggtitle("Forecasts for quarterly beer production") +
xlab("Year") + ylab("Megalitres") +
guides(colour=guide_legend(title="Forecast"))
# 데이터: google200, goog
train <- window(goog200,start=1992, end=c(2007,4))
# 데이터: google200, goog
train <- goog200
test <- window(goog, start = 201, end = 240)
meanf <- meanf(train, h=40)
accuracy(meanf, test)
rwf <- rwf(train, h=40)
accuracy(rwf, test)
rwf_d <- rwf(train, drift=T, h=40)
accuracy(rwf_d, test)
# 데이터: google200, goog
train <- goog200
test <- window(goog, start = 201, end = 240)
meanf <- meanf(train, h=40)
accuracy(meanf, test)
rwf <- rwf(train, h=40)
accuracy(rwf, test)
rwf_d <- rwf(train, drift=T, h=40)
accuracy(rwf_d, test)
autoplot(goog200) +
autolayer(meanf, series="Mean", PI=FALSE) +
autolayer(rwf, series="Naive", PI=FALSE) +
autolayer(rwf_d, series="Drift", PI=FALSE) +
ggtitle("Google stock (daily ending 6 Dec 2013)") +
xlab("Day") + ylab("Closing Price (US$)") +
guides(colour=guide_legend(title="Forecast"))
autoplot(goog) +
autolayer(meanf, series="Mean", PI=FALSE) +
autolayer(rwf, series="Naive", PI=FALSE) +
autolayer(rwf_d, series="Drift", PI=FALSE) +
ggtitle("Google stock (daily ending 6 Dec 2013)") +
xlab("Day") + ylab("Closing Price (US$)") +
guides(colour=guide_legend(title="Forecast"))
data <- window(goog, end = 240)
autoplot(goog) +
autolayer(meanf, series="Mean", PI=FALSE) +
autolayer(rwf, series="Naive", PI=FALSE) +
autolayer(rwf_d, series="Drift", PI=FALSE) +
ggtitle("Google stock (daily ending 6 Dec 2013)") +
xlab("Day") + ylab("Closing Price (US$)") +
guides(colour=guide_legend(title="Forecast"))
autoplot(data) +
autolayer(meanf, series="Mean", PI=FALSE) +
autolayer(rwf, series="Naive", PI=FALSE) +
autolayer(rwf_d, series="Drift", PI=FALSE) +
ggtitle("Google stock (daily ending 6 Dec 2013)") +
xlab("Day") + ylab("Closing Price (US$)") +
guides(colour=guide_legend(title="Forecast"))
# meanf(), rwf(), snaive() 로 예측하기
# 데이터 : ausbeer
train <- window(ausbeer,start=1992, end=c(2007,4))
test <- window(ausbeer, start = c(2008,1))
meanf <- meanf(train, h=10)
accuracy(meanf, test)
rwf <- rwf(train, h=10)
accuracy(rwf, test)
snaive <- snaive(train, h=10)
accuracy(snaive, test)
autoplot(beer2) +
autolayer(meanf, series="Mean", PI=FALSE) +
autolayer(rwf, series="Naive", PI=FALSE) +
autolayer(snaive, series="Seasonal naive", PI=FALSE) +
ggtitle("Forecasts for quarterly beer production") +
xlab("Year") + ylab("Megalitres") +
guides(colour=guide_legend(title="Forecast"))
# 데이터: google200, goog
train <- goog200
test <- window(goog, start = 201, end = 240)
meanf <- meanf(train, h=40)
accuracy(meanf, test)
rwf <- rwf(train, h=40)
accuracy(rwf, test)
rwf_d <- rwf(train, drift=T, h=40)
accuracy(rwf_d, test)
data <- window(goog, end = 240)
autoplot(data) +
autolayer(meanf, series="Mean", PI=FALSE) +
autolayer(rwf, series="Naive", PI=FALSE) +
autolayer(rwf_d, series="Drift", PI=FALSE) +
ggtitle("Google stock (daily ending 6 Dec 2013)") +
xlab("Day") + ylab("Closing Price (US$)") +
guides(colour=guide_legend(title="Forecast"))
autoplot(train+test) +
autolayer(meanf, series="Mean", PI=FALSE) +
autolayer(rwf, series="Naive", PI=FALSE) +
autolayer(rwf_d, series="Drift", PI=FALSE) +
ggtitle("Google stock (daily ending 6 Dec 2013)") +
xlab("Day") + ylab("Closing Price (US$)") +
guides(colour=guide_legend(title="Forecast"))
autoplot(data) +
autolayer(meanf, series="Mean", PI=FALSE) +
autolayer(rwf, series="Naive", PI=FALSE) +
autolayer(rwf_d, series="Drift", PI=FALSE) +
ggtitle("Google stock (daily ending 6 Dec 2013)") +
xlab("Day") + ylab("Closing Price (US$)") +
guides(colour=guide_legend(title="Forecast"))
# 데이터: google200, goog
train <- goog200
test <- window(goog, start = 201, end = 240)
meanf <- meanf(train, h=40)
accuracy(meanf, test)
rwf <- rwf(train, h=40)
accuracy(rwf, test)
rwf_d <- rwf(train, drift=T, h=40)
accuracy(rwf_d, test)
# meanf(), rwf(), snaive() 로 예측하기
# 데이터 : ausbeer
train <- window(ausbeer,start=1992, end=c(2007,4))
test <- window(ausbeer, start = c(2008,1))
meanf <- meanf(train, h=10)
accuracy(meanf, test)
rwf <- rwf(train, h=10)
accuracy(rwf, test)
snaive <- snaive(train, h=10)
accuracy(snaive, test)
setwd('/Users/wan/GitHub/Portfolio_Optimization/time_series_clustering')
load('dtw_clustering.RData')
getwd()
ksp
head(ksp)
ksp_part_now
head(ksp_part_now)
tail(ksp_part_now)
tail(ksp_part_next)
head(ksp_part_next)
head(ksp_part_now)
krw <- read.csv('data/krw.csv')
krw
library(dplyr)
glimpse(krw)
library(timetk)
library(dplyr)
glimpse(krw)
library(timetk)
krw_price <- krw[c(1, 2)]
krw_price
colnames(krw_price) <- (c('Date', 'Price'))
krw_price <- na.omit(krw_price)
krw_price
library(readr)
krw_price
krw_price$Price <- parse_number(krw_price$Price) # 열에서 숫자만 추출
krw_price$Date <- ymd(krw_price$Date) # ymd()로 형태를 yyyy-mm-dd로 변경
krw_price <- tk_xts(krw_price, date_var = Date) # tk_xts()로 시계열로 변경, 인덱스: krw_price$Date
krw_price
krw_price$Price <- parse_number(krw_price$Price) # 열에서 숫자만 추출
### 코스피
kospi <- read.csv('data/kospi.csv')
library(dplyr)
glimpse(kospi)
library(timetk)
kospi_price <- kospi[c(1, 2)]
colnames(kospi_price) <- (c('Date', 'Price'))
kospi_price <- na.omit(kospi_price)
library(readr)
kospi_price$Price <- parse_number(kospi_price$Price) # 열에서 숫자만 추출
kospi_price$Date <- ymd(kospi_price$Date) # ymd()로 형태를 yyyy-mm-dd로 변경
kospi_price <- tk_xts(kospi_price, date_var = Date) # tk_xts()로 시계열로 변경, 인덱스: kospi_price$Date
kospi_price$Date <- ymd(kospi_price$Date) # ymd()로 형태를 yyyy-mm-dd로 변경
krw <- read.csv('data/krw.csv')
krw
library(dplyr)
glimpse(krw)
library(timetk)
krw_price <- krw[c(1, 2)]
colnames(krw_price) <- (c('Date', 'Price'))
krw_price <- na.omit(krw_price)
library(readr)
krw_price$Price <- parse_number(krw_price$Price) # 열에서 숫자만 추출
krw_price$Date <- ymd(krw_price$Date) # ymd()로 형태를 yyyy-mm-dd로 변경
krw_price$Price <- parse_number(krw_price$Price) # 열에서 숫자만 추출
krw_price$Date <- ymd(krw_price$Date) # ymd()로 형태를 yyyy-mm-dd로 변경
library(timetk)
krw_price$Date <- ymd(krw_price$Date) # ymd()로 형태를 yyyy-mm-dd로 변경
?ymd
library(lubridate)
krw_price$Date <- ymd(krw_price$Date) # ymd()로 형태를 yyyy-mm-dd로 변경
krw_price <- tk_xts(krw_price, date_var = Date) # tk_xts()로 시계열로 변경, 인덱스: krw_price$Date
print(tail(krw_price))
krw
glimpse(krw)
krw_price
head(krw_price)
write.csv(data.frame(krw_price), 'data/krw_close.csv')
krw = read.csv('data/krw_close.csv', row.names = 1,
stringsAsFactors = FALSE) %>% as.xts()
krw = read.csv('data/krw_close.csv', row.names = 1,
stringsAsFactors = FALSE) %>% as.xts()
library(quantmod)
library(PerformanceAnalytics)
library(RiskPortfolios)
library(tidyr)
library(dplyr)
library(ggplot2)
krw = read.csv('data/krw_close.csv', row.names = 1,
stringsAsFactors = FALSE) %>% as.xts()
krw
head(krw)
glimpse(krw)
glimpse(ksp)
krw
KOR_fs = readRDS('data/KOR_fs.Rds')
KOR_value = read.csv('data/KOR_value.csv', row.names = 1,
stringsAsFactors = FALSE)
KOR_price = read.csv('data/KOR_price.csv', row.names = 1,
stringsAsFactors = FALSE) %>% as.xts()
KOR_ticker = read.csv('data/KOR_ticker.csv', row.names = 1,
stringsAsFactors = FALSE)
KOR_ticker$'종목코드' =
str_pad(KOR_ticker$'종목코드', 6, 'left', 0)
library(quantmod)
library(Quandl)
# 사용되는 지표
# - 퀄리티: 자기자본이익률, 매출 총이익, 영업활동현금흐름
# - 밸류: PER, PBR, PSR, PCR
# - 모멘텀: 3개월 수익률, 6개월 수익률, 12개월 수익률
library(dplyr)
library(xts)
library(stringr)
library(tidyr)
KOR_ticker$'종목코드' =
str_pad(KOR_ticker$'종목코드', 6, 'left', 0)
### 퀄리티 지표 계산
if ( lubridate::month(Sys.Date()) %in% c(1,2,3,4) ) {
num_col = str_which(colnames(KOR_fs[[1]]), as.character(lubridate::year(Sys.Date()) - 2))
} else {
num_col = str_which(colnames(KOR_fs[[1]]), as.character(lubridate::year(Sys.Date()) - 1))
}
# 자기자본이익률
quality_roe = (KOR_fs$'지배주주순이익' / KOR_fs$'자본')[num_col]
#매출총이익
quality_gpa = (KOR_fs$'매출총이익' / KOR_fs$'자산')[num_col]
# 영업활동현금흐름
quality_cfo =
(KOR_fs$'영업활동으로인한현금흐름' / KOR_fs$'자산')[num_col]
quality_profit =
cbind(quality_roe, quality_gpa, quality_cfo) %>%
setNames(., c('ROE', 'GPA', 'CFO'))
factor_quality = quality_profit %>%
mutate_all(list(~min_rank(desc(.)))) %>%
mutate_all(list(~scale(.))) %>%
rowSums()
# Z-Score의 히스토그램
factor_quality %>%
data.frame() %>%
ggplot(aes(x = `.`)) +
geom_histogram()
### 밸류 지표 계산
factor_value = KOR_value %>%
mutate_all(list(~min_rank(.))) %>%
mutate_all(list(~scale(.))) %>%
rowSums()
factor_value %>%
data.frame() %>%
ggplot(aes(x = `.`)) +
geom_histogram()
### 모멘텀 지표 계산
library(PerformanceAnalytics)
library(dplyr)
ret_3m = Return.calculate(KOR_price) %>% xts::last(60) %>%
sapply(., function(x) {prod(1+x) - 1})
ret_6m = Return.calculate(KOR_price) %>% xts::last(120) %>%
sapply(., function(x) {prod(1+x) - 1})
ret_12m = Return.calculate(KOR_price) %>% xts::last(252) %>%
sapply(., function(x) {prod(1+x) - 1})
ret_bind = cbind(ret_3m, ret_6m, ret_12m) %>% data.frame()
factor_mom = ret_bind %>%
mutate_all(list(~min_rank(desc(.)))) %>%
mutate_all(list(~scale(.))) %>%
rowSums()
factor_mom %>%
data.frame() %>%
ggplot(aes(x = `.`)) +
geom_histogram()
### 팩터 간 상관관계 확인
library(corrplot)
cbind(factor_quality, factor_value, factor_mom) %>%
data.frame() %>%
setNames(c('Quality', 'Value', 'Momentum')) %>%
cor(use = 'complete.obs') %>%
round(., 2) %>%
corrplot(method = 'color', type = 'upper',
addCoef.col = 'black', number.cex = 1,
tl.cex = 0.6, tl.srt = 45, tl.col = 'black',
col =
colorRampPalette(c('blue', 'white', 'red'))(200),
mar=c(0,0,0.5,0))
factor_qvm =
cbind(factor_quality, factor_value, factor_mom) %>%
data.frame() %>%
mutate_all(list(~scale(.))) %>%
# 분포가 다르기 때문에 다시 한 번 scale()로 정규화
mutate(factor_quality = factor_quality * 0.33,
factor_value = factor_value * 0.33,
factor_mom = factor_mom * 0.33) %>%
# 각 팩터에 동일한 비중(0.33) 곱하기
rowSums() # 최종 합
# 최종적으로 기준 상위 20종목 선택
invest_qvm = rank(factor_qvm) <= 20
data.frame(cbind("ticker" = KOR_ticker[,1][invest_qvm],
"corp" = KOR_ticker[,2][invest_qvm]))
ksdq_next_period
ksdq_next_period[[1]][[1]]
glimpse(ksdq_next_period[[1]][[1]])
as.numeric(ksdq_next_period[[1]][[1]])
parse_number(ksdq_next_period[[1]][[1]])
parse_number(ksdq_next_period[[1]])
parse_number(ksdq_next_period[[1]]) >= 2019
ksdq_next_period[[1]][parse_number(ksdq_next_period[[1]]) >= 2019]
parse_number(ksdq_next_period[[1]]
parse_number(ksdq_next_period[[1]])
parse_number(ksdq_next_period[[1]])
parse_number(ksdq_next_period[[1]])[1]
ksdq_next_period[[1]]
ksdq_next_period[[1]][1]
ksdq_next_period[[1]][1][1]
ksdq_next_period[[1]][1][-1]
ksdq_next_period[[1]][1][2]
ksdq_next_period[[1]][[1]][1]
ksdq_next_period[[1]][[1]][[1]]
ksdq_next_period[[1]]
ksdq_next_period[[1]][1]
str_sub(ksdq_next_period[[1]][1], '-','')
str_sub('-','', ksdq_next_period[[1]][1])
gsub('-','', ksdq_next_period[[1]][1])
glimpse(gsub('-','', ksdq_next_period[[1]][1]))
as.numeric(gsub('-','', ksdq_next_period[[1]][1]))
as.numeric(gsub('-','', ksdq_next_period[[1]][1]))
as.numeric(gsub('-','', ksdq_next_period[[1]][1])) >= 201106
as.numeric(gsub('-','', ksdq_next_period[[1]][1])) >= 201104
as.numeric(gsub('-','', ksdq_next_period[[1]][1])) >= 201103
as.numeric(gsub('-','', ksdq_next_period[[1]][1])) #>= 201103
